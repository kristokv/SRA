stack(combined.duration)[1])
combined.abundance
combined.ages
combined.spds
combined.duration
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
#Setting the number of boostrap samples
#Setting the number of boostrap samples (note that 1000 iterations takes some time...)
B <- 1000
n <- dim(Data)[1]
Data$Abundance<-Data$Abundance/Data$Dur
#Splitting the data by year
Data.list <- split(Data,Data$Year)
#Data-frame of to successive stages, same as above
combined.abundance<-data.frame(cbind(dat[,stages[i]],dat[,stages[i+1]]))
combined.ages<-data.frame(cbind(dat[,paste0("Age.",stages[i])],dat[,paste0("Age.",stages[i+1])]))
combined.spds<-data.frame(cbind(dat[,paste0("Spd.",stages[i])],dat[,paste0("Spd.",stages[i+1])]))
combined.duration<-data.frame(cbind(dat[,paste0("Duration.",stages[i])],dat[,paste0("Duration.",stages[i+1])]))
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
#Doing the bootstrap with year as the sampling unit
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
#Setting the number of boostrap samples (note that 1000 iterations takes some time...)
B <- 1000
n <- dim(Data)[1]
#Splitting the data by year
Data.list <- split(Data,Data$Year)
names(Data.list) <- yrs
#To store the resulting bootstrap vectors:
boot.av.m <- NULL
boot.yr.m <- NULL
boot.sd.yr.m <- NULL
B<-10
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b,weights=Data.b$Weight ) #
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b)
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
boot.av.m <-(-boot.av.m) #The negative of the estimates give mortality
low.95.M <- quantile(boot.av.m,0.025)
up.95.M <- quantile(boot.av.m,0.975)
m_table<-data.frame(lowM=low.95.M,upM=up.95.M)
m_table
mortalities
#Function to estimate mortality for copepodite stages by iterative solution:
mortality <- function(a1,a2,d1,d2,m.seq=seq(-3,3,by=0.0001)){ #Searching in possible m values between -3 and 3, intervals of 0.0001
#a1=abundance of stage i, a2=abundance of stage i+1
#d1=stage duration of stage i,d2=stage duration of stage i+1
#m.seq=possible mortality values from which to interpolate the estimated value
r<-a1/a2 #ratio between abundance of stage 1 and subsequent stage 2
ifelse(!is.na(r) & !is.infinite(r),
m.est<-approx(y=m.seq,x=(exp(m.seq*d1)-1)/(1-exp(-m.seq*d2))-r,xout=0), #Estimated m for copepodite stages
m.est<-c(NA,NA)) #If ratio is a missing or infinite value, return NA
return(m.est[2])
}
M<-matrix(NA,nrow=length(dat[,1]),ncol=5) #Matrix to store mortality estimates per sampling station
colnames(M)<-trans
#For CI-CIV (this takes a little while...)
for (i in c(1:4)) {
for (j in c(1:length(dat[,1]))) {
M[j,i]<-unlist(mortality(a1=dat[j,stages[i]],a2=dat[j,stages[i+1]],
d1=dat[j,paste0("Duration.",stages[i])],d2=dat[j,paste0("Duration.",stages[i+1])]))
}
}
dim()
i<-5
d1<-dat[j,paste0("Duration.",stages[i])]
r<-dat[,stages[i]]/dat[,stages[i+1]] #CV-CVI.F
r[is.infinite(r)]<-NA
M[,5]<-log(r+1)/d1
#Estimate average mortality + 95%CI
se <- function(x) sqrt(var(x,na.rm=TRUE)/length(na.omit(x))) #Function to calculate standard error
meantab<-array(NA,dim=c(length(trans),3))
dimnames(meantab)<-list(trans,c("Mean","Up","Low"))
meantab[,1]<-apply(M,2,FUN=mean,na.rm=TRUE)
meantab[,2]<-apply(M,2,FUN=mean,na.rm=TRUE)+1.96*apply(M,2,FUN=se)
meantab[,3]<-apply(M,2,FUN=mean,na.rm=TRUE)-1.96*apply(M,2,FUN=se)
meantab
mort_true<-c(0.09,0.105,0.075,0.03,0.025,0.02) #Stage-specific mortalities per copepodite stage (CI-CVI) used in the simulation
mort_avg<-sapply(1:(length(mort_true)-1), function(i) mean(mort_true[i:(i+1)])) #Averaged per stage pair
#Get the confidence intervals from the bootstrap per stage-pair in one matrix
mort.ci<-array(NA,dim=c(4,2))
dimnames(mort.ci)<-list(trans[-5],c("Up","Low"))
for (i in c(1:4)) {
m.coef<-read.table(file=paste(Bootpath,"m_table.",trans[i],".",B,".txt",sep=""),header=T,sep ='')
mort.ci[trans[i],"Up"]<-as.numeric(m.coef[2])
mort.ci[trans[i],"Low"]<-as.numeric(m.coef[1])
}
B
#Do the bootstrap per stage-pair
for (i in c(1:4)) {
#Data-frame of to successive stages, same as above
combined.abundance<-data.frame(cbind(dat[,stages[i]],dat[,stages[i+1]]))
combined.ages<-data.frame(cbind(dat[,paste0("Age.",stages[i])],dat[,paste0("Age.",stages[i+1])]))
combined.spds<-data.frame(cbind(dat[,paste0("Spd.",stages[i])],dat[,paste0("Spd.",stages[i+1])]))
combined.duration<-data.frame(cbind(dat[,paste0("Duration.",stages[i])],dat[,paste0("Duration.",stages[i+1])]))
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
#Doing the bootstrap with year as the sampling unit
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
n <- dim(Data)[1]
#Splitting the data by year
Data.list <- split(Data,Data$Year)
names(Data.list) <- yrs
#To store the resulting bootstrap vectors:
boot.av.m <- NULL
boot.yr.m <- NULL
boot.sd.yr.m <- NULL
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b)
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
boot.av.m <-(-boot.av.m) #The negative of the estimates give mortality
### Calculation of upper and lower confidence limits for model coefficients (for standard errors, replace 'quantile(x,0.025)' with 'sd(x)')
low.95.M <- quantile(boot.av.m,0.025)
up.95.M <- quantile(boot.av.m,0.975)
m_table<-data.frame(lowM=low.95.M,upM=up.95.M)
#Save the confidence intervals
write.table(m_table,file=paste(Bootpath,"m_table.",trans[i],".txt",sep=""),row.names=TRUE)
}
#########################################
#Vertical Life Table approach (VLT)
#Aksnes, DL, Ohman MD.  1996.  A vertical life table approach to zooplankton mortality estimation. Limnology and Oceanography. 41:1461-1469.
getwd()
Bootpath
paste(Bootpath,"m_table.",trans[i],".txt",sep="")
Bootpath<- "/Bootstrap/" #The directory for saving bootstrap results
#Do the bootstrap per stage-pair
for (i in c(1:4)) {
#Data-frame of to successive stages, same as above
combined.abundance<-data.frame(cbind(dat[,stages[i]],dat[,stages[i+1]]))
combined.ages<-data.frame(cbind(dat[,paste0("Age.",stages[i])],dat[,paste0("Age.",stages[i+1])]))
combined.spds<-data.frame(cbind(dat[,paste0("Spd.",stages[i])],dat[,paste0("Spd.",stages[i+1])]))
combined.duration<-data.frame(cbind(dat[,paste0("Duration.",stages[i])],dat[,paste0("Duration.",stages[i+1])]))
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
#Doing the bootstrap with year as the sampling unit
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
n <- dim(Data)[1]
#Splitting the data by year
Data.list <- split(Data,Data$Year)
names(Data.list) <- yrs
#To store the resulting bootstrap vectors:
boot.av.m <- NULL
boot.yr.m <- NULL
boot.sd.yr.m <- NULL
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b)
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
boot.av.m <-(-boot.av.m) #The negative of the estimates give mortality
### Calculation of upper and lower confidence limits for model coefficients (for standard errors, replace 'quantile(x,0.025)' with 'sd(x)')
low.95.M <- quantile(boot.av.m,0.025)
up.95.M <- quantile(boot.av.m,0.975)
m_table<-data.frame(lowM=low.95.M,upM=up.95.M)
#Save the confidence intervals
write.table(m_table,file=paste(Bootpath,"m_table.",trans[i],".txt",sep=""),row.names=TRUE)
}
#########################################
#Vertical Life Table approach (VLT)
paste(Bootpath,"m_table.",trans[i],".txt",sep="")
Bootpath<- "Bootstrap/" #The directory for saving bootstrap results
write.table(m_table,file=paste(Bootpath,"m_table.",trans[i],".txt",sep=""),row.names=TRUE)
#Do the bootstrap per stage-pair
for (i in c(1:4)) {
#Data-frame of to successive stages, same as above
combined.abundance<-data.frame(cbind(dat[,stages[i]],dat[,stages[i+1]]))
combined.ages<-data.frame(cbind(dat[,paste0("Age.",stages[i])],dat[,paste0("Age.",stages[i+1])]))
combined.spds<-data.frame(cbind(dat[,paste0("Spd.",stages[i])],dat[,paste0("Spd.",stages[i+1])]))
combined.duration<-data.frame(cbind(dat[,paste0("Duration.",stages[i])],dat[,paste0("Duration.",stages[i+1])]))
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
#Doing the bootstrap with year as the sampling unit
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
n <- dim(Data)[1]
#Splitting the data by year
Data.list <- split(Data,Data$Year)
names(Data.list) <- yrs
#To store the resulting bootstrap vectors:
boot.av.m <- NULL
boot.yr.m <- NULL
boot.sd.yr.m <- NULL
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b)
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
boot.av.m <-(-boot.av.m) #The negative of the estimates give mortality
### Calculation of upper and lower confidence limits for model coefficients (for standard errors, replace 'quantile(x,0.025)' with 'sd(x)')
low.95.M <- quantile(boot.av.m,0.025)
up.95.M <- quantile(boot.av.m,0.975)
m_table<-data.frame(lowM=low.95.M,upM=up.95.M)
#Save the confidence intervals
write.table(m_table,file=paste(Bootpath,"m_table.",trans[i],".txt",sep=""),row.names=TRUE)
}
Bootmat<-matrix(NA,nrow=2,ncol=length(trans)-1) #Matrix to store bootstrap results
bootmat<-matrix(NA,nrow=2,ncol=length(trans)-1) #Matrix to store bootstrap results
bootmat<-matrix(NA,nrow=2,ncol=length(trans)-1) #Matrix to store bootstrap results
colnames(bootmat)<-trans[-5]
rownames(bootmat)<-c("Up","Down") #Upper and lower confidence limits for model coefficients
bootmat
bootmap["Low",i] <- quantile(boot.av.m,0.025)
bootmat["Low",i] <- quantile(boot.av.m,0.025)
#Do the bootstrap per stage-pair
for (i in c(1:4)) {
#Data-frame of to successive stages, same as above
combined.abundance<-data.frame(cbind(dat[,stages[i]],dat[,stages[i+1]]))
combined.ages<-data.frame(cbind(dat[,paste0("Age.",stages[i])],dat[,paste0("Age.",stages[i+1])]))
combined.spds<-data.frame(cbind(dat[,paste0("Spd.",stages[i])],dat[,paste0("Spd.",stages[i+1])]))
combined.duration<-data.frame(cbind(dat[,paste0("Duration.",stages[i])],dat[,paste0("Duration.",stages[i+1])]))
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
#Doing the bootstrap with year as the sampling unit
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
n <- dim(Data)[1]
#Splitting the data by year
Data.list <- split(Data,Data$Year)
names(Data.list) <- yrs
#To store the resulting bootstrap vectors:
boot.av.m <- NULL
boot.yr.m <- NULL
boot.sd.yr.m <- NULL
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b)
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
boot.av.m <-(-boot.av.m) #The negative of the estimates give mortality
### Calculation of upper and lower confidence limits for model coefficients (for standard errors, replace 'quantile(x,0.025)' with 'sd(x)')
bootmat["Low",i] <- quantile(boot.av.m,0.025)
bootmat["Up",i] <- quantile(boot.av.m,0.975)
}
i
bootmat["Low",i]
bootmat
rownames(bootmat)<-c("Up","Low") #Upper and lower confidence limits for model coefficients
for (i in c(1:4)) {
#Data-frame of to successive stages, same as above
combined.abundance<-data.frame(cbind(dat[,stages[i]],dat[,stages[i+1]]))
combined.ages<-data.frame(cbind(dat[,paste0("Age.",stages[i])],dat[,paste0("Age.",stages[i+1])]))
combined.spds<-data.frame(cbind(dat[,paste0("Spd.",stages[i])],dat[,paste0("Spd.",stages[i+1])]))
combined.duration<-data.frame(cbind(dat[,paste0("Duration.",stages[i])],dat[,paste0("Duration.",stages[i+1])]))
Data<-data.frame(cbind(rep(dat$Year,2),
rep(dat$Day,2),
rep(dat$Lon,2),
rep(dat$Lat,2),
stack(combined.abundance)[1],
stack(combined.ages)[1],
stack(combined.spds)[1]),
stack(combined.duration)[1])
colnames(Data)<-c("Year","Abs.day","Lon.dec","Lat.dec","Abundance","Age","Spd","Dur")
Data<-Data[!is.na(Data$Abundance) & Data$Abundance>0,]
Data$Abundance<-Data$Abundance/Data$Dur
Data$Year.num<-as.numeric(as.character(Data$Year))
Data$Age<-scale(Data$Age,center=TRUE,scale=FALSE)
#Doing the bootstrap with year as the sampling unit
yrs <- as.character(levels(Data$Year))
n.yrs <- length(years)
n <- dim(Data)[1]
#Splitting the data by year
Data.list <- split(Data,Data$Year)
names(Data.list) <- yrs
#To store the resulting bootstrap vectors:
boot.av.m <- NULL
boot.yr.m <- NULL
boot.sd.yr.m <- NULL
for(b in 1:B){
#Sample years
yrs.B <- sample(yrs,size=length(yrs),replace=T)
#Constructing a bootstrap data set of the sampled years:
Data.b <- NULL
for(j in 1:length(yrs.B)){
Data.b.j <- Data.list[[yrs.B[j]]] #Taking the data for year #j in the sample
Data.b.j$year <- yrs[j]  #Renaming the year the #j in the original order
Data.b <- rbind.data.frame(Data.b,Data.b.j) #Creating a dataframe of samples
}
#Redefining the year variable (same number of levels as original, some might have zero occurence):
Data.b$Year <- factor(x=as.character(Data.b$year),levels=levels(Data$Year))
#Estimate mortality from the resampled dataset
m.b <- gam(log(Data.b$Abundance)~s(Spd)+te(Lon.dec,Lat.dec)+s(Year,bs="re")+Age+s(Year,bs="re",by=Age),data=Data.b)
av.m <- coef(m.b)["Age"]
#Store the estimates
boot.av.m <- c(boot.av.m,av.m)
}
boot.av.m <-(-boot.av.m) #The negative of the estimates give mortality
### Calculation of upper and lower confidence limits for model coefficients (for standard errors, replace 'quantile(x,0.025)' with 'sd(x)')
bootmat["Low",i] <- quantile(boot.av.m,0.025)
bootmat["Up",i] <- quantile(boot.av.m,0.975)
}
mort_true<-c(0.09,0.105,0.075,0.03,0.025,0.02) #Stage-specific mortalities per copepodite stage (CI-CVI) used in the simulation
mort_avg<-sapply(1:(length(mort_true)-1), function(i) mean(mort_true[i:(i+1)])) #Averaged per stage pair
bootmat
par(mfrow=c(2,2),mar=c(3,2,1,1),oma=c(0.5,2,0.5,0))
plot(1, type="n", xlab="", ylab="", xlim=c(0, 5),ylim=c(min(c(bootmat,meantab),na.rm=TRUE),max(c(mort.ci,meantab),na.rm=TRUE)+0.02),axes=FALSE,frame=TRUE)
par(oma=c(0.5,2,0.5,0))
plot(1, type="n", xlab="", ylab="", xlim=c(0, 5),ylim=c(min(c(bootmat,meantab),na.rm=TRUE),max(c(mort.ci,meantab),na.rm=TRUE)+0.02),axes=FALSE,frame=TRUE)
par(oma=c(0.5,2,0.5,0))
dev.off()
par(oma=c(0.5,2,0.5,0))
plot(1, type="n", xlab="", ylab="", xlim=c(0, 5),ylim=c(min(c(bootmat,meantab),na.rm=TRUE),max(c(mort.ci,meantab),na.rm=TRUE)+0.02),axes=FALSE,frame=TRUE)
Axis(side=1, at=seq(0.5,4.5,length.out = 4),labels=FALSE)
Axis(side=2, labels=TRUE)
text(seq(0.5,4.5,length.out = 4), par("usr")[3]-0.01,labels =trans[c(1:4)], srt = 45, pos = 1, xpd = TRUE)
par(oma=c(0.5,1,0.5,0))
plot(1, type="n", xlab="", ylab="", xlim=c(0, 5),ylim=c(min(c(bootmat,meantab),na.rm=TRUE),max(c(mort.ci,meantab),na.rm=TRUE)+0.02),axes=FALSE,frame=TRUE)
Axis(side=1, at=seq(0.5,4.5,length.out = 4),labels=FALSE)
Axis(side=2, labels=TRUE)
text(seq(0.5,4.5,length.out = 4), par("usr")[3]-0.01,labels =trans[c(1:4)], srt = 45, pos = 1, xpd = TRUE)
#TRUE ESTIMATE
points(seq(0.5,4.5,length.out = 4),mort_avg[1:4],pch=15,cex=1.1)
points(seq(0.5,4.5,length.out = 4),mort_true[1:4],pch=0,cex=1.1)
#VLT
points(seq(0.3,4.3,length.out = 4),meantab[1:4,1],pch=16,cex=1.5,col="dark green")
arrows(x0=seq(0.3,4.3,length.out = 4),x1=seq(0.3,4.3,length.out = 4),y0=meantab[1:4,2],y1=meantab[1:4,3],length=0.05, angle=90,code=3,lty=2,col="dark green")
points(seq(0.7,4.7,length.out = 4),mortalities.tot[x,],pch=17,cex=1.5,col="blue")
points(seq(0.7,4.7,length.out = 4),mortalities,pch=17,cex=1.5,col="blue")
arrows(x0=seq(0.7,4.7,length.out = 4),x1=seq(0.7,4.7,length.out = 4),y0=mort.ci[,1],y1=mort.ci[,2],length=0.05, angle=90,code=3,lty=2,col="blue")
meantab
plot(1, type="n", xlab="", ylab="", xlim=c(0, 5),ylim=c(min(c(bootmat,meantab),na.rm=TRUE),max(c(mort.ci,meantab),na.rm=TRUE)+0.02),axes=FALSE,frame=TRUE)
Axis(side=1, at=seq(0.5,4.5,length.out = 4),labels=FALSE)
Axis(side=2, labels=TRUE)
text(seq(0.5,4.5,length.out = 4), par("usr")[3]-0.01,labels =trans[c(1:4)], srt = 45, pos = 1, xpd = TRUE)
#TRUE ESTIMATE
points(seq(0.5,4.5,length.out = 4),mort_avg[1:4],pch=15,cex=1.1)
points(seq(0.5,4.5,length.out = 4),mort_true[1:4],pch=0,cex=1.1)
points(seq(0.3,4.3,length.out = 4),meantab[1:4,1],pch=16,cex=1.5,col="dark green")
arrows(x0=seq(0.3,4.3,length.out = 4),x1=seq(0.3,4.3,length.out = 4),y0=meantab[1:4,2],y1=meantab[1:4,3],length=0.05, angle=90,code=3,lty=2,col="dark green")
meantab
points(seq(0.7,4.7,length.out = 4),mortalities,pch=17,cex=1.5,col="blue")
arrows(x0=seq(0.7,4.7,length.out = 4),x1=seq(0.7,4.7,length.out = 4),y0=bootmat[1,],y1=bootmat[2,],length=0.05, angle=90,code=3,lty=2,col="blue")
legend("topright",c("True mean","True pr. stage","VLT","SRA"),pch=c(15,0,16,17),cex=1.2,bty="n",horiz=F,seg.len=2,
col=c("black","black","dark green","blue"))
legend("topright",c("True mean","True pr. stage","VLT","SRA"),pch=c(15,0,16,17),cex=1.2,bty="n",horiz=F,seg.len=2,
col=c("black","black","dark green","blue"))
par(oma=c(0.5,1,0.5,0))
plot(1, type="n", xlab="", ylab="", xlim=c(0, 5),ylim=c(min(c(bootmat,meantab),na.rm=TRUE),max(c(mort.ci,meantab),na.rm=TRUE)+0.02),axes=FALSE,frame=TRUE)
Axis(side=1, at=seq(0.5,4.5,length.out = 4),labels=FALSE)
Axis(side=2, labels=TRUE)
text(seq(0.5,4.5,length.out = 4), par("usr")[3]-0.01,labels =trans[c(1:4)], srt = 45, pos = 1, xpd = TRUE)
#TRUE ESTIMATE
points(seq(0.5,4.5,length.out = 4),mort_true[1:4],pch=0,cex=1.1)
points(seq(0.5,4.5,length.out = 4),mort_avg[1:4],pch=15,cex=1.1)
#VLT
points(seq(0.3,4.3,length.out = 4),meantab[1:4,1],pch=16,cex=1.5,col="dark green")
arrows(x0=seq(0.3,4.3,length.out = 4),x1=seq(0.3,4.3,length.out = 4),y0=meantab[1:4,2],y1=meantab[1:4,3],length=0.05, angle=90,code=3,lty=2,col="dark green")
#SRA
points(seq(0.7,4.7,length.out = 4),mortalities,pch=17,cex=1.5,col="blue")
arrows(x0=seq(0.7,4.7,length.out = 4),x1=seq(0.7,4.7,length.out = 4),y0=bootmat[1,],y1=bootmat[2,],length=0.05, angle=90,code=3,lty=2,col="blue")
legend("topright",c("True mean","True pr. stage","VLT","SRA"),pch=c(15,0,16,17),cex=1.2,bty="n",horiz=F,seg.len=2,
col=c("black","black","dark green","blue"))
mtext(expression(paste("Mortality rate (",d^-1,")")),side=2,outer=TRUE,line=0.7)
trans<-c("CI-CII","CII-CIII","CIII-CIV","CIV-CV") #Copepodite stage pairs for which we estimate mortality
length(trans)
